 **Мутабельность** (от англ. *mutability*) — это свойство объекта в программировании, которое определяет, можно ли изменить его состояние или содержимое после создания.

### 🔹 **Мутабельные vs. Немутабельные объекты**
1. **Мутабельные (изменяемые)** – объекты, которые можно модифицировать после создания.
    - Примеры в Python: списки (`list`), словари (`dict`), множества (`set`).
    - Пример изменения списка:
      ```python
      my_list = [1, 2, 3]
      my_list.append(4)  # изменяем список
      print(my_list)  # [1, 2, 3, 4]
      ```  

2. **Немутабельные (неизменяемые)** – объекты, которые нельзя изменить после создания.
    - Примеры в Python: числа (`int`, `float`), строки (`str`), кортежи (`tuple`).
    - Пример со строкой:
      ```python
      my_str = "hello"
      # my_str[0] = "H"  # Ошибка! Строку изменить нельзя
      new_str = my_str.replace("h", "H")  # создаётся новая строка
      print(new_str)  # "Hello"
      ```  

### 🔹 **Почему важно понимать мутабельность?**
- **Безопасность данных**: неизменяемые объекты защищены от случайных изменений.
- **Хешируемость**: неизменяемые объекты можно использовать как ключи в словарях.
- **Производительность**: некоторые оптимизации (например, кеширование) работают лучше с неизменяемыми данными.

### 🔹 **Пример с передачей в функции**


# Мутабельные объекты передаются по ссылке, поэтому их можно изменить внутри функции:
```python
def add_item(lst, item):
    lst.append(item)

my_list = [1, 2, 3]
add_item(my_list, 4)
print(my_list)  # [1, 2, 3, 4] – изменился!
```  

Немутабельные объекты передаются по значению (фактически, создаётся копия):
```python
def change_string(s):
    s = s.upper()

my_str = "hello"
change_string(my_str)
print(my_str)  # "hello" – не изменился!
```  

### 🔹 **Как сделать объект немутабельным?**
В Python можно использовать:
- `tuple` вместо `list`,
- `frozenset` вместо `set`,
- `namedtuple` или `dataclass(frozen=True)` для неизменяемых структур.

### **Вывод**
Мутабельность влияет на поведение объектов при модификации, передаче в функции и использовании в структурах данных. Выбор между изменяемыми и неизменяемыми типами зависит от задачи.
В JavaScript мутабельность (mutability) также играет важную роль. Давайте разберём, какие типы данных изменяемые, а какие — нет, и как это влияет на работу с ними.

---

## 🔹 **Мутабельные и немутабельные типы в JavaScript**
### 1. **Немутабельные (immutable) типы**
- При изменении создаётся **новая копия**, исходные данные не меняются.
- Примеры:
    - `string`
    - `number`
    - `boolean`
    - `null`
    - `undefined`
    - `Symbol`

**Пример с `string`:**
   ```javascript
   let str = "Hello";
   let newStr = str.replace("H", "h"); // Создаётся новая строка
   console.log(str);    // "Hello" (не изменилась)
   console.log(newStr); // "hello" (новая строка)
   ```

### 2. **Мутабельные (mutable) типы**
- Можно изменять **без создания новой копии**.
- Примеры:
    - `Object`
    - `Array`
    - `Map`
    - `Set`
    - `Date`

**Пример с `Array`:**
   ```javascript
   let arr = [1, 2, 3];
   arr.push(4); // Изменяем исходный массив
   console.log(arr); // [1, 2, 3, 4] (изменился)
   ```

---

## 🔹 **Почему важно учитывать мутабельность?**
### 1. **Неожиданные изменения в функциях**
Мутабельные объекты передаются **по ссылке**, поэтому их можно случайно изменить внутри функции.

   ```javascript
   function addItem(list, item) {
       list.push(item); // Мутация исходного массива!
   }

   const nums = [1, 2, 3];
   addItem(nums, 4);
   console.log(nums); // [1, 2, 3, 4] – массив изменился!
   ```

**Решение:** Использовать копирование (например, `[...arr]` или `Object.assign({}, obj)`).

   ```javascript
   function addItemSafe(list, item) {
       return [...list, item]; // Новый массив
   }

   const nums = [1, 2, 3];
   const newNums = addItemSafe(nums, 4);
   console.log(nums);    // [1, 2, 3] – не изменился
   console.log(newNums); // [1, 2, 3, 4]
   ```

### 2. **Сравнение объектов**
Немутабельные значения сравниваются **по значению**, а мутабельные — **по ссылке**.

   ```javascript
   const str1 = "hello";
   const str2 = "hello";
   console.log(str1 === str2); // true (значения одинаковы)

   const obj1 = { a: 1 };
   const obj2 = { a: 1 };
   console.log(obj1 === obj2); // false (разные ссылки!)
   ```

**Решение:** Для сравнения объектов можно использовать:
- `JSON.stringify(obj1) === JSON.stringify(obj2)` (не всегда надёжно),
- библиотеки типа `lodash.isEqual()`.

### 3. **Оптимизация и иммутабельность**
- В React/Redux **неизменяемые данные** помогают избежать лишних ререндеров.
- Легче отслеживать изменения (например, в `useEffect`).

---

## 🔹 **Как работать с мутабельностью?**
### 1. **Создание копий мутабельных объектов**
- **Массивы:**
  ```javascript
  const arr = [1, 2, 3];
  const copyArr = [...arr]; // или arr.slice()
  ```
- **Объекты:**
  ```javascript
  const obj = { a: 1, b: 2 };
  const copyObj = { ...obj }; // или Object.assign({}, obj)
  ```
- **Глубокая копия:**
  ```javascript
  const deepCopy = JSON.parse(JSON.stringify(obj)); // (осторожно: не работает с функциями и Symbol)
  ```

### 2. **Использование иммутабельных библиотек**
- **Immer.js** – позволяет писать мутабельный код, но генерирует неизменяемые структуры.
  ```javascript
  import produce from "immer";

  const newState = produce(state, draft => {
      draft.user.name = "Alice"; // "Мутация" в черновике
  });
  ```
- **Immutable.js** – предоставляет неизменяемые коллекции (`List`, `Map` и др.).

---

## 🔹 **Вывод**
- **Немутабельные:** `string`, `number`, `boolean` – безопасны, но при изменениях создаётся копия.
- **Мутабельные:** `Object`, `Array` – удобны, но могут приводить к неожиданным изменениям.
- **Лучшие практики:**
    - Использовать копирование (`...spread`, `Object.assign`).
    - В React/Redux предпочитать иммутабельные обновления.
    - Для сложных структур – библиотеки (`Immer`, `Immutable.js`).

Понимание мутабельности помогает избежать багов и писать более предсказуемый код! 🚀


В JavaScript данные делятся на **примитивные (immutable, немутабельные)** и **объектные (mutable, мутабельные)** типы. Разберём их подробно.

---

## 🔹 **1. Примитивные (немутабельные) типы**
Хранятся **по значению**, при изменении создаётся новая копия.

### 📌 **Список примитивных типов**:
1. **`number`** – числа (целые, дробные, `NaN`, `Infinity`).
   ```javascript
   let a = 10;
   let b = a; // Копирование значения
   b = 20;
   console.log(a); // 10 (не изменилось)
   ```

2. **`string`** – строки.
   ```javascript
   let str = "Hello";
   str[0] = "h"; // Не сработает (строка неизменяема)
   console.log(str); // "Hello"
   ```

3. **`boolean`** – логические значения (`true`/`false`).
   ```javascript
   let isDone = true;
   isDone = false; // Присваивание нового значения
   ```

4. **`null`** – явное отсутствие значения.
5. **`undefined`** – значение не определено.
6. **`Symbol`** (ES6) – уникальный идентификатор.
   ```javascript
   const id = Symbol("id");
   ```

7. **`bigint`** (ES11) – целые числа произвольной длины.
   ```javascript
   const bigNum = 100n;
   ```

---

## 🔹 **2. Объектные (мутабельные) типы**
Хранятся **по ссылке**, можно изменять содержимое.

### 📌 **Список объектных типов**:
1. **`Object`** – коллекция ключ-значение.
   ```javascript
   const obj = { name: "Alice" };
   obj.name = "Bob"; // Изменение возможно
   ```

2. **`Array`** – упорядоченный список.
   ```javascript
   const arr = [1, 2, 3];
   arr.push(4); // Мутация исходного массива
   ```

3. **`Function`** – функции (являются объектами).
   ```javascript
   function greet() { console.log("Hi!"); }
   greet.newProp = 123; // Можно добавлять свойства
   ```

4. **`Date`** – дата и время.
5. **`RegExp`** – регулярные выражения.
6. **`Map`**, **`Set`**, **`WeakMap`**, **`WeakSet`** (ES6).

---

## 🔹 **3. Особенности поведения**
### 🔸 **Сравнение примитивов и объектов**
- Примитивы сравниваются **по значению**:
  ```javascript
  "a" === "a" // true
  5 === 5     // true
  ```
- Объекты сравниваются **по ссылке**:
  ```javascript
  {} === {} // false (разные ссылки)
  [1, 2] === [1, 2] // false
  ```

### 🔸 **Пример мутабельности объекта**
```javascript
const user = { name: "Alice" };
const admin = user; // Копируется ссылка
admin.name = "Bob";

console.log(user.name); // "Bob" – исходный объект изменился!
```

### 🔸 **Как избежать мутаций?**
1. **Копирование объектов**:
   ```javascript
   const newObj = { ...oldObj }; // Spread-оператор
   const newArr = [...oldArr];
   ```
2. **Глубокая копия**:
   ```javascript
   const deepCopy = JSON.parse(JSON.stringify(obj));
   ```
3. **Иммутабельные библиотеки**:
    - `Immer` – позволяет работать с данными как с мутабельными, но возвращает новый объект.
    - `Immutable.js` – предоставляет неизменяемые структуры данных.

---

## 🔹 **4. Проверка типов: `typeof` и `instanceof`**
- **`typeof`** – возвращает тип примитива или `"object"`/`"function"`:
  ```javascript
  typeof 42;          // "number"
  typeof "text";      // "string"
  typeof {};          // "object"
  typeof [];          // "object" (массив – это объект!)
  typeof function(){}; // "function"
  typeof null;        // "object" (исторический баг)
  ```
- **`instanceof`** – проверяет, принадлежит ли объект классу/конструктору:
  ```javascript
  [] instanceof Array; // true
  {} instanceof Object; // true
  ```

---

## 🔹 **5. Итоговая таблица типов**
| Тип                | Категория     | Пример                  | Мутабельность  |
|--------------------|--------------|-------------------------|----------------|
| `number`           | Примитивный  | `10`, `3.14`, `NaN`     | Немутабельный  |
| `string`           | Примитивный  | `"hello"`               | Немутабельный  |
| `boolean`          | Примитивный  | `true`, `false`         | Немутабельный  |
| `null`             | Примитивный  | `null`                  | Немутабельный  |
| `undefined`        | Примитивный  | `undefined`             | Немутабельный  |
| `Symbol`           | Примитивный  | `Symbol("id")`          | Немутабельный  |
| `bigint`           | Примитивный  | `100n`                  | Немутабельный  |
| `Object`           | Объектный    | `{}`, `{ key: "value" }`| Мутабельный    |
| `Array`            | Объектный    | `[1, 2, 3]`             | Мутабельный    |
| `Function`         | Объектный    | `function(){}`          | Мутабельный    |
| `Date`             | Объектный    | `new Date()`            | Мутабельный    |
| `RegExp`           | Объектный    | `/abc/`                 | Мутабельный    |

---

## 🔹 **Вывод**
- **Примитивы** – простые, неизменяемые, сравниваются по значению.
- **Объекты** – сложные, изменяемые, сравниваются по ссылке.
- **Важно:**
    - При работе с объектами/массивами учитывать мутабельность.
    - Использовать копирование или иммутабельные подходы, чтобы избежать неожиданных изменений.
    - Для проверки типов комбинировать `typeof` и `instanceof`.

Понимание типов данных в JS помогает писать более надежный и предсказуемый код! 🚀
